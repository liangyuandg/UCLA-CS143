package simpledb;

import java.util.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends Operator {

    private static final long serialVersionUID = 1L;

    private DbIterator child1;
    private DbIterator child2;

    private Tuple child1Tup;

    private JoinPredicate predicate;

    /**
     * Constructor. Accepts to children to join and the predicate to join them
     * on
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.child1 = child1;
        this.child2 = child2;
        this.child1Tup = null;
        this.predicate = p;
    }

    public JoinPredicate getJoinPredicate() {
        return this.predicate;
    }

    /**
     * @return
     *       the field name of join field1. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField1Name() {
        return this.child1.getTupleDesc().getFieldName(this.predicate.getField1());
    }

    /**
     * @return
     *       the field name of join field2. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField2Name() {
        return this.child2.getTupleDesc().getFieldName(this.predicate.getField2());
    }

    /**
     * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
     *      implementation logic.
     */
    public TupleDesc getTupleDesc() {
        TupleDesc td1 = this.child1.getTupleDesc();
        TupleDesc td2 = this.child2.getTupleDesc();
        return TupleDesc.merge(td1, td2);
    }

    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        super.open();
        this.child1.open();
        this.child2.open();
   }

    public void close() {
        super.close();
        this.child1.close();
        this.child2.close();
    }

    public void rewind() throws DbException, TransactionAbortedException {
        this.child1.rewind();
        this.child2.rewind();
        this.child1Tup = null;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation of joining tuples from the left and right
     * relation. Therefore, if an equality predicate is used there will be two
     * copies of the join attribute in the results. (Removing such duplicate
     * columns can be done with an additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     * 
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        /* TODO: Describe your implementation in your lab writeup. */
        /* Note: with the way that TestUtil.matchAllTuples's implemented, 
           this becomes quite inefficient as rewinds on this.child1 and this.child2 happens very often.
           The test method only checks for existence of expected in actual, 
           and does not check if the number of occurrences is correct, and could be misleading.
           Besides it also caused confusion for debugging. 
           A better test method would be: walk through actual, walk through expected, compare elements, O(n^2) or not. */
        Tuple tup1 = null;
        Tuple tup2 = null;

        if (this.child1Tup != null) {
            while (this.child2.hasNext()) {
                tup1 = this.child1Tup;
                tup2 = this.child2.next();

                if (this.predicate.filter(tup1, tup2)) {
                    this.child1Tup = tup1;
                    return joinTuples(tup1, tup2);
                }
            }
        }

        while (this.child1.hasNext()) {
            tup1 = this.child1.next();
            this.child2.rewind();
            while (this.child2.hasNext()) {
                tup2 = this.child2.next();

                if (this.predicate.filter(tup1, tup2)) {
                    this.child1Tup = tup1;
                    return joinTuples(tup1, tup2);
                }
            }
        }
        return null;
    }

    private Tuple joinTuples(Tuple tup1, Tuple tup2) {
        Tuple result = new Tuple(this.getTupleDesc());
        for (int i = 0; i < this.child1.getTupleDesc().numFields(); i++) {
            result.setField(i, tup1.getField(i));
        }
        for (int i = 0; i < this.child2.getTupleDesc().numFields(); i++) {
            result.setField(i + this.child1.getTupleDesc().numFields(), tup2.getField(i));
        }
        return result;
    }

    @Override
    public DbIterator[] getChildren() {
        DbIterator[] childrenArray = new DbIterator[2];
        childrenArray[0] = this.child1;
        childrenArray[1] = this.child2;
        return childrenArray;
    }

    @Override
    public void setChildren(DbIterator[] children) {
        if (children.length > 1) {
            this.child1 = children[0];
            this.child2 = children[1];
        }
    }

}
